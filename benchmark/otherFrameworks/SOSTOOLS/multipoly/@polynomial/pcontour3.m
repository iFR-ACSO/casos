function varargout = pcontour3(p,v,domain,npts,var)
% function [F,V,C] = pcontour3(p,v,domain,npts,var)
%
% DESCRIPTION 
%   Plots contour surfaces of p(x,y,z) at the values specified by the 
%   vector v. The contours are generated numerically by evaluating p on a 
%   grid of values of x,y,z and then calling the ISOSURFACE function. 
%
% INPUTS 
%   p: 1-by-1 polynomial of three variables
%   v: N-by-1 vector of contour values (Default: v=1)
%   domain: 1-by-6 vector specifying the plotting domain,
%              [Xmin Xmax Ymin Ymax Zmin Zmax] 
%         (Default: domain = [-1 1 -1 1 -1 1])
%   npts: 1-by-3 vector specifying the number of grid points along
%          each axis, [Num of X pts, Num of Y pts, Num of Z pts] 
%          (Default: npts = [50 50 50])
%   var: 1-by-3 vector of pvars specifying the x/y/z axis variables,
%          [Variable for X axis, Variable for Y axis, Variable for Z axis]
%          (Default var = p.var)
%              
% OUTPUTS  
%   F,V,C: Faces, vertices, and facevertexcdata generated by ISOSURFACE.
%         The 1,2, and 3 variable outputs are the same as those generated
%         by ISOSURFACE.
%  
% SYNTAX 
%  pcontour3(p)
%  pcontour3(p,v)
%  pcontour3(p,v,domain)
%  pcontour3(p,v,domain,npts)
%  pcontour3(p,v,domain,npts,var)
%  [F,V,C] = pcontour3(p,v,domain,npts,var)
%
% EXAMPLE
%  pvar x y z
%  domain = [-3.5 3.5 -1.5 1.5 -1.5 1.5];
%  p1 = x^2+y^2+z^2;
%  ph1= patch(pcontour3(p1,2,domain));
%  set(ph1, 'FaceColor', 'none', 'EdgeColor', 'red' );
%  p2 = x^2/4+2*y^2+3*z^2;
%  ph2= patch(pcontour3(p2,2,domain));
%  set(ph2, 'FaceColor', 'blue', 'EdgeColor', 'none' );
%  view(3); axis equal
%
% See also pcontour, isosurface

% PJS 5/7/08   Initial coding
% PJS 11/23/10 Removed SOS call for domain

%-------------------------------------------------------------------
% Error Checking
%-------------------------------------------------------------------


%-------------------------------------------------------------------
% Set defaults 
%-------------------------------------------------------------------
if nargin==1
    v=[];
    domain=[];
    npts=[];
    var=[];
elseif nargin==2    
    domain=[];
    npts=[];
    var=[];
elseif nargin==3
    npts=[];
    var=[];
elseif nargin==4
    var=[];
end

% Default contour
if isempty(v)
    v=1;
end

% Default options
if isempty(npts)
    Nx = 50;
    Ny = 50;
    Nz = 50;
else
    Nx = npts(1);
    if length(npts)<3
        Ny = Nx;
        Nz = Nx;
    else
        Ny = npts(2);
        Nz = npts(3);
    end    
end

% Define variables as chars
if isempty(var)
    x = p.varname{1};
    y = p.varname{2};
    z = p.varname{3};
elseif ispvar(var) || iscellstr(var)
    if ispvar(var)
        var = char(var);
    end
    x = var{1};
    y = var{2};
    z = var{3};
else
    error('var must be a vector of pvars');
end

% if isempty(domain) && exist('sosopt.m')==2
%     % Compute default axis values using SOS optimization
%     xl = zeros(lv,1); xu = zeros(lv,1);
%     yl = zeros(lv,1); yu = zeros(lv,1);
%     zl = zeros(lv,1); zu = zeros(lv,1);
%     for i1=1:lv
%         % Bounds
%         xl(i1) = -LOCALxub(p,-x,v(i1));
%         xu(i1) = LOCALxub(p,x,v(i1));
%         
%         yl(i1) = -LOCALxub(p,-y,v(i1));
%         yu(i1) = LOCALxub(p,y,v(i1));
%         
%         zl(i1) = -LOCALxub(p,-z,v(i1));
%         zu(i1) = LOCALxub(p,z,v(i1));
%     end
%     xl = min(xl); xu = max(xu);
%     yl = min(yl); yu = max(yu);
%     zl = min(zl); zu = max(zu);
%     
%     xpad = 0.1*(xu-xl);
%     domain = [0 0 0 0];
%     if xpad<=0
%         domain(1:2) = [xl-1 xl+1];
%     else
%         domain(1:2) = [xl-xpad, xu+xpad];
%     end
%     
%     ypad = 0.1*(yu-yl);
%     if ypad<=0
%         domain(3:4) = [yl-1 yl+1];
%     else
%         domain(3:4) = [yl-ypad, yu+ypad];
%     end
% 
%     zpad = 0.1*(zu-zl);
%     if zpad<=0
%         domain(5:6) = [zl-1 zl+1];
%     else
%         domain(5:6) = [zl-zpad, zu+zpad];
%     end
% elseif isempty(domain)
if isempty(domain)
    domain = [-1 1 -1 1 -1 1];
end    
    
% Plot contour
xg = linspace(domain(1),domain(2),Nx);
yg = linspace(domain(3),domain(4),Ny);
zg = linspace(domain(5),domain(6),Nz);
[xg,yg,zg] = meshgrid(xg,yg,zg);
%pgrid = double(subs(p,{x,y,z},{xg(:),yg(:),zg(:)}));
%pgrid = reshape(pgrid,Nx,Ny,Nz);
pgrid = double(subs(p,{x,y,z},[xg(:), yg(:), zg(:)]'));
pgrid = reshape(pgrid,size(xg));

if nargout==0
    isosurface(xg,yg,zg,pgrid,v);    
    axis(domain)
    xlabel(x)
    ylabel(y)
    zlabel(z)
elseif nargout==1
    F=isosurface(xg,yg,zg,pgrid,v);    
    varargout = {F};
elseif nargout==2
    [F,V]=isosurface(xg,yg,zg,pgrid,v);    
    varargout = {F,V};
elseif nargout==3
    [F,V,C]=isosurface(xg,yg,zg,pgrid,v);    
    varargout = {F,V,C};
end
  
% %------------------------------------------------------------------------
% % Local function which computes an upper bound on:
% %       max x   s.t. p(x,y)=v
% % The bound is computed by relaxing the optimization to:
% %       min g    s.t. -x-h*(v-p)+g in SOS
% %------------------------------------------------------------------------
% function  xub = LOCALxub(p,x,v)
% 
% pvar g;
% h = polydecvar('c',1,'vec');
% 
% s=-x-h*(v-p)+g;
% [info,dopt,sossol] = sosopt(s,p.var,g);
% if ~info.feas
%     % Polynomial might be unbounded
%     xub = 1e3;
% else
%     xub = subs(g,dopt(:,1),dopt(:,2));
% end
